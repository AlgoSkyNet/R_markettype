---
title: "Detect Market status with AI"
output: html_notebook
---

## Purpose

This work aims to develop sets of tools and procedures that will help trader to efficiently guess Financial Asset Market Type. Whether it's a Bullish or Bearish Market, Ranging, Volatile - Author believes that having this ability to detect market type and use it in trading would be of a great advantage!

## Task outlay

Basic idea of achieveing this will be:

- Manually classify data from forex pairs into periods
- Extract MACD indicator corresponding to the periods
- Create combined dataset with classified data
- Fit regression NN model
- Productionize model for the new coming data!
- In MQL side:
    - set flags (e.g. bullish: sell = False)
    - fine tune parameters. (e.g. set up specific market period and find parameters by using optimization)

- Required to read time series data, visualize it as time-series data, transform to matrix, visualize again as 3D, train the model...

## Load packages

```{r message=FALSE, warning=FALSE, paged.print=FALSE}
library(tidyverse)
library(lubridate)
library(plotly)
library(h2o)
```

## Data read

```{r}
# path to actual prices
Path_T2 <- "C:/Program Files (x86)/FxPro - Terminal2/MQL4/Files/"
# load prices of 28 currencies
prices <- read_csv(file.path(Path_T2, "AI_CP15.csv"), col_names = F)
prices <- read_csv("AI_CP15.csv", col_names = F)
prices$X1 <- ymd_hms(prices$X1)
# load macd indicator of 28 currencies
macd <- read_csv(file.path(Path_T2, "AI_Macd15.csv"), col_names = F)
# use this option to use sample data:
macd <- read_csv("AI_Macd15.csv", col_names = F)
macd$X1 <- ymd_hms(macd$X1)
```

## Catching specific market periods

I would manually change Y variable in the plot until I find siutable market condition...

1. Bull normal
2. Bull volatile
3. Bear normal
4. Bear volatile
5. Sideways quiet
6. Sideways volatile



### 1. Bull normal

```{r}
ggplot(prices, aes(X1, X3))+geom_line()
```

We will extract only corresponding piece...

```{r}
# extract approximate date and choose only relevant columns
bull_norm <- prices %>% filter(X1 > "2017-11-05", X1 < "2017-11-25") %>% select(X1, X3)
```

... and visualize it to confirm 

```{r}
ggplot(bull_norm, aes(X1, X3))+geom_line()
```

next, we can extract corresponding piece of macd dataframe:

```{r}
macd_bull_norm <- macd %>% select(X1, X3) %>% inner_join(bull_norm, by = c("X1" = "X1"))
```

and visualize both things together

```{r}
ggplot(macd_bull_norm, aes(X1, X3.y, col = X3.x))+geom_line()
```

let's now use this function:

```{r}
macd_m_bull_norm <- macd_bull_norm %>% select(X3.x) %>% to_m(100)
```

## Visualize new matrix in 3D

```{r}
plot_ly(z = macd_m_bull_norm, type = "surface")
```


## Trying to fit model now:

```{r}
# start h2o virtual machine
h2o.init()
# load data into h2o environment
macd_bv  <- as.h2o(x = macd_m_bull_norm, destination_frame = "macd_bull_norm")
```

```{r}
# fit the model
deepnet_model <- h2o.deeplearning(
 x = names(macd_bv), 
 training_frame = macd_bv, 
 activation = "Tanh", 
 autoencoder = TRUE, 
 hidden = c(50,20,50), 
 sparse = TRUE,
 l1 = 1e-4, 
 epochs = 100)
```

Any time need to make a pause?

```{r}
#h2o.shutdown(prompt = F)
```

```{r}
# check mse
mod_error <- h2o.anomaly(deepnet_model, test_M4) %>% as.data.frame()

mod_error
mod_error %>% summarise(mean_mse = mean(Reconstruction.MSE))
```

We should also try to reduce or increase complexity of this model

```{r}
# fit the model A
SimpleA <- h2o.deeplearning(
 x = names(macd_bv), 
 training_frame = macd_bv, 
 activation = "Tanh", 
 autoencoder = TRUE, 
 hidden = c(50,20,50), 
 sparse = TRUE,
 l1 = 1e-4, 
 epochs = 100)
mod_errA <- h2o.anomaly(SimpleA, macd_bv) %>% as.data.frame() %>% summarise(mean_mse = mean(Reconstruction.MSE))
# fit the model B
SimpleB <- h2o.deeplearning(
 x = names(macd_bv), 
 training_frame = macd_bv, 
 activation = "Tanh", 
 autoencoder = TRUE, 
 hidden = c(70,50,70), 
 sparse = TRUE,
 l1 = 1e-4, 
 epochs = 100)
mod_errB <- h2o.anomaly(SimpleB, macd_bv) %>% as.data.frame() %>% summarise(mean_mse = mean(Reconstruction.MSE))
# fit the model C
SimpleC <- h2o.deeplearning(
 x = names(macd_bv), 
 training_frame = macd_bv, 
 activation = "Tanh", 
 autoencoder = TRUE, 
 hidden = c(30,10,30), 
 sparse = TRUE,
 l1 = 1e-4, 
 epochs = 100)
mod_errC <- h2o.anomaly(SimpleC, macd_bv) %>% as.data.frame() %>% summarise(mean_mse = mean(Reconstruction.MSE))
# fit the model D
SimpleD <- h2o.deeplearning(
 x = names(macd_bv), 
 training_frame = macd_bv, 
 activation = "Tanh", 
 autoencoder = TRUE, 
 hidden = c(100,20,100), 
 sparse = TRUE,
 l1 = 1e-4, 
 epochs = 100)
mod_errD <- h2o.anomaly(SimpleD, macd_bv) %>% as.data.frame() %>% summarise(mean_mse = mean(Reconstruction.MSE))
# fit the model E
SimpleE <- h2o.deeplearning(
 x = names(macd_bv), 
 training_frame = macd_bv, 
 activation = "Tanh", 
 autoencoder = TRUE, 
 hidden = c(70,50,20,50,70), 
 sparse = TRUE,
 l1 = 1e-4, 
 epochs = 100)
mod_errE <- h2o.anomaly(SimpleE, macd_bv) %>% as.data.frame() %>% summarise(mean_mse = mean(Reconstruction.MSE))

```

Summarise what we get

```{r}
mod_errA
mod_errB
mod_errC
mod_errD
mod_errE
```


This model A was already good, the MSE slightly reduced moving to sligtly complex one... we will leave Model_B...

## Save the model

```{r}
if(!file.exists("models/bull_norm.bin")){
h2o.saveModel(SimpleA, "models/bull_norm.bin")
}

h2o.shutdown(prompt = F)
```

## Conclusion

This procedure can be repeated for every market period... and hopefully it will bring some fruits...?



# Utility Code

## Adapting function to_m

```{r}

# Function converting time series data to matrix
to_m <- function(x, n_cols) {
  ### PURPOSE: Transform Time Series Column of the dataframe to the matrix
  #            with specified number of columns. Number of rows will be automatically
  #            found and remaining data points discarded
  # # Uncomment variable to debug function
  # x -< dataframe with one column
  
  # x <- DF_TEMP
  # n_cols <- 150
  
  # get intermediate object and dimension
  Step1 <- x
  # find number of rows of data frame
  nrows <- Step1 %>% nrow()
  # find the number of row in a matrix (Whole Rows), the value will have decimals...
  WN <- nrows/n_cols
  ## extract the whole number uncomment for debug/test
  # WN <- 19.2
  # WN <- 19.8
  if((WN - round(WN)) < 0){WN <- round(WN) - 1} else {WN <- round(WN)}
  # find number of rows to extract data
  n <- n_cols * WN
  # extract relevant matrix
  Step2 <- Step1 %>% 
    head(n) %>% #only use whole number to avoid errors
    t() %>%  # this brings us a matrix
    matrix(nrow = WN, ncol = n_cols, byrow = TRUE) # transforming that into matrix size 20x150
  # return the result of the function
  return(Step2)
}

```


## Install fresh copy of h2o

See www.h2o.ai

```{r eval=FALSE, include=FALSE}
# The following two commands remove any previously installed H2O packages for R.
if ("package:h2o" %in% search()) { detach("package:h2o", unload=TRUE) }
if ("h2o" %in% rownames(installed.packages())) { remove.packages("h2o") }

# Next, we download packages that H2O depends on.
pkgs <- c("RCurl","jsonlite")
for (pkg in pkgs) {
if (! (pkg %in% rownames(installed.packages()))) { install.packages(pkg) }
}

# Now we download, install and initialize the H2O package for R.
install.packages("h2o", type="source", repos="http://h2o-release.s3.amazonaws.com/h2o/rel-wheeler/2/R")
```

